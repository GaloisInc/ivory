\section{Related Work}
\label{sec:related-work}

The general idea of safe C languages is not new; our main contribution is
embedding a type system into GHC as well as our support of verification
tools.

Pioneering work in the area is the Cyclone language and
compiler~\cite{cyclone}. Cyclone is a dialect of C. Cyclone is less restrictive than
Ivory, relying on both static analysis and runtime checks to enforce memory
safety. Cyclone provides regions for dynamic memory allocation; garbage
collection is optional. Cyclone programs are typically slightly larger than
their C equivalents and mostly syntactically the same. In contrast to Ivory,
Cyclone does not provide macro-programming facilities (beyond the C
preprocessor), nor does it interface to verification and testing
tools. Unfortunately, Cyclone is not actively maintained.

Bit-data and memory areas in Ivory borrow heavily from Diatchki~et~al.'s
previous work~\cite{high-level, memareas}. Indeed, one can consider the present
work as demonstrating the feasibility of embedding this language into Haskell
and GHC types. BitC is another language deprecated research language that
explored a similar design space~\cite{bitc}.

Spark/Ada is a mature language for high-assurance embedded
programming, with a contract language and verification tools to
prove invariants~\cite{spark}. To support verification, the language is
very restrictive; in particular, there are no references in the language.

Rust is an actively-developed safe C language, originating from
Mozilla~\cite{rust}. Rust has a powerful type system to enforce safely using
heap-based data structures. An affine type system prevents pointer aliasing
errors. Rust provides reference counting garbage collection as a library (so
other garbage collection strategies can be used instead). Rust has hygenic
macros. The language has a property-based testing framework, but no mature
support for verification, or even static checks for undefined behavior (e.g.,
division by a constant zero expression).

EDSLs for safe C programming also exist. Examples include Atom, a language for
lock-free embedded programs~\cite{atom}; Copilot, a stream-oriented synchronous
language~\cite{copilot}; SBV, a Haskell-based SMT symbolic simulator with a C code
generator~\cite{sbv}; and Feldspar, a language specialized for high-level and
efficient specifications of digital signal processing~\cite{feldspar1}. Compared to these
languages, Ivory is more focused on the kinds of C in low-level code, such as
device drivers, with bit-data and memory area manipulation.
